Ονομα:Hλιας
Επιθετο:Bεργος
Α.Μ: 1115201400266


							ΕΠΕΞΗΓΗΣΗ ΑΣΚΗΣΗΣ 1 ΠΡΟΓΡΑΜΜΑΤΙΣΜΟΣ ΣΥΣΤΗΜΑΤΟΣ

Προγραμματιστικο Περιβαλλον:Linux
Eντολη μεταγλωττισης:make
Eντολη (τυχαια) εκτελεσης: ./myexe -o Operations -h1 10 -h2 10 -s 400 -c config
Oπου Οperations ειναι το αρχειο με τις εντολες και config το αρχειο με τις χρεωσεις.
-h1 (αριθμος)-->hashtable1 size.
-h2	(αριθμος)-->hashtable2 size.
-s (αριθμος σε bytes)-->μεγεθος του καθε bucket του hashtable.
-c (αρχειο).
-ο (αρχειο).
Αυτη ειναι η δομη της εντολης εκτελεσης.

Πηγες που χρησιμοποιηθηκαν απο το διαδικτυο:
1)Για την hash function χρησιμοποιησα το example2 (Multiplication method)
	https://courses.csail.mit.edu/6.006/spring11/rec/rec05.pdf
2)Για την εισαγωγη στοιχειων στο binary max heap και πιο συγκεκριμενα για την ευρεση της σωστης θεσης του καινουργιου κομβου πηρα ιδεες απο αυτο το site:
	http://theoryofprogramming.com/2015/02/01/binary-heaps-and-heapsort-algorithm/
3)Και τελος για την ταξινομηση ενος πινακα που ηθελα να κανω στην topdest χρησιμοποιησα τον αλγοριθμο insertion sort που βρηκα στο site:
	http://quiz.geeksforgeeks.org/insertion-sort/
Ολα τα υπολοιπα τα εκανα μονος μου.



Περιγραφη ασκησης:
Λιγα λογια για τις δομες:
1)To hashtable μου αποτελειται απο μια δομη hashtable που περιεχει ενα δεικτη σε bucket,ενα δεικτη στην αρχη της λιστας των bucket,τον αριθμο ολων των bucket που περιεχει μια θεση του hashtable και τον αριθμο στοιχειων ολων των bucket.
2)To bucket αποτελειται απο ενα δεικτη σε bucket_node ,ενα δεικτη σε επομενο κομβο bucket ,και τον αριθμο στοιχειων του συγκεκριμενου bucket.
3)To bucket_node περιεχει ενα αριθμο που ειναι ο καλων ή αυτος που καλειται αναλογα σε ποιο hashtable ειμαστε,αριθμος ολων των στοιχειων των λιστων,αριθμο λιστων ,ενα δεικτη σε λιστα,ενα δεικτη στην πρωτη λιστα αυτου του bucket_node.
4)Tην λιστα που περιεχει τον αριθμο στοιχειων της ,ενα δεικτη σε επομενη λιστα και ενα δεικτη στην εγγραφη.
5)Για την εγγραφη εχω δημιουργησει μια δομη date για την ημερομηνια ,μια δομη time για την ωρα(την εχω σε a.m και p.m),
μια δομη number που ειναι ο τηλεφωνικος αριθμος(ο κωδικος ειναι string και ο 10-ψηφιος αριθμος ειναι int οποτε καποιες φορες οταν ξεκιναει με 0 δεν το δειχνει).
6)Το max heap μου ειναι ενα δεντρο με κομβους που περιεχουν δυο δεικτες για τα παιδια(left,right),ενα δεικτη για τον κομβο πατερα, ενα id(σε δυαδικο) που με βοηθα να βρισκω σε ποιο κομβο βρισκομαι,ενα flag για την ευρεση του μεγιστου στην συναρτηση top k,το επιπεδο στο οποιο βρισκεται ο κομβος ,το ποσο και τον αριθμο.

Στην υπολοιπη περιγραφη θα αναφερω ξεχωριστα τι κανει καθε μια απο τις βασικες συναρτησεις που μας ζητουνται να υλοποιηθουν.

1)void top(maxHeap*,int k):
Η συναρτηση αυτη με στελνει σε μια αλλα βοηθητικη συναρτηση αφου πρωτα ελενχει αν υπαρχει το maxheap που δωθηκε.Εκει αφου βρω το ποσο που θα χρειαστει μεσω του ποσοστου(k που μας δινεται) εκτυπωνω τον max κομβο μου που ειναι η ριζα σε καθε binary max heap,και στην συνεχεια καλω μια αναδρομικη συναρτηση η οποια αναλογα το επιπεδο και τα flag του καθε κομβου σαρωνει του κομβους που χρειαζεται και βρισκει τον επομενο max κομβο.Το flag του κομβου αυτου γινεται 1 και μετα η συναρτηση δεν το ξανακοιτα.Οταν τελειωσει η συναρτηση καλει την επισης αναδρομικη βοηθητικη συναρτηση change_flag που βαζει ολες τις σημαιες σε 0.

2)void delete(hashtable** hashtable1,char* id,number num,int bucket_size,int hashtable1_size,int hashtable2_size,maxHeap*):
Αρχικα ψαχνω να δω αν το id και ο αριθμος που ηρθε υπαρχουν στο hashtable.Aν δεν υπαρχουν τερματιζει με καταλληλο μυνημα αλλιως διαγραφει την συγκεκριμενη εγγραφη απο το hashtable1 και παει ολα τα επομενα στοιχεια μια θεση πανω.

3)void topdest(number caller,hashtable**,int,int):
Aρχικα ψαχνω να βρω αν υπαρχει ο caller .Αν δεν υπαρχει τερματιζει αλλιως βαζει σε ενα πινακα δομη ολες τις εγγραφες και ενα μετρητη για καθε μια ,υστερα κανω ταξινομηση με βαση τον μετρητη και τελος εκτυπωνω τα/το max.

4)void bye(hashtable** hashtable1,hashtable** hashtable2,int hashtable_size1,int hashtable_size2,int bucket_size,maxHeap** hp)
Μεσα σε αυτην την συναρτηση αρχικα καλω την deleteHeap που μου διαγραφει το δενρο με το binary max heap,και στην συνεχεια μολις επιστρεψει απο την διαγραφη του δεντρου διαγραφω αρχιακ το hashtable1 απο μεσα προς τα εξω δηλαδη πρωτα εγγραφες ,λιστες, bucket_nodes, buckets, και τελος hashtable.To ιδιο κανω στην συνεχεια και για το hashtable2.

5)void print_hashtable(hashtable* hashtable,int hashtable_size,char* name,int bucket_size,maxHeap*)
Εδω εκτυπωνω το hashtable που μου δινεται .Αν εχω λιστα απο bucket υπαρχει ενα "βελακι" κατω απο την λεξη bucket που σε πηγαινει στο επομενο και αν εχω λιστα απο λιστες τοτε εχω παλι ενα "βελακι" κατω απο το ονομα της λιστας που σε πηγαινει στην επομενη λιστα.Η διαφορα απο τα δυο βελακια πιστευω ειναι εμφανης .

6)void indist(hashtable** hashtable1,hashtable** hashtable2,number num1,number num2,int hashtable_size,int bucket_size)
Οπως αναφερω και στα σχολια η διαδιακασια εδω ειναι αρκετα μεγαλη και γιαυτο τον λογο θα την αναφερω αρκετα περιληπτικα.Αρχικα ψαχνω να βρω τις θεσεις στα buckets των αριθμων που μου ζητουνται στο hashtable1(number1,number2).Mετα βαζω σε 2 πινακες τις εγγραφες που πηρα απο τα buckets.Tην ιδια διαδικασια κανω για να παρω τις εγγραφες απο το hashtable2 και τις βαζω στους ιδιους πινακες με τις προηγουμενες εγγραφες.Ετσι στον 1ο πινακα εχω αυτους που επικοινωνησαν με τον number1 και στον 2ο αυτους που επικοινωνησαν με τον number2.Tα κοινα στοιχεια αυτων των 2 πινακων θα ειναι οι "υποψηφιοι" που θα εχουν μιλησει και με τους 2.Υστερα,θα επαναλαβω για καθε κοινο στοιχειο που βρηκα την διαδικασια που περιγραφηκε παραπανω για να βρω ποιοι απο αυτους εχουν μιλησει μεταξυ τους.Οσοι πληρουν τα κριτηρια θα εκτυπωθουν.

7)void find(number caller,hashtable** hashtable,int hashtable_size,int bucket_size,time time1,time time2,date year1,date year2)
Αρχικα ψαχνω να βρω τις θεσεις στα buckets του αριθμου που μου ζητηται(hashtable1).Aφου το βρω ελενχω αναλογα με τις ωρες και τις ημερομηνιες που μου δινονται τι πρεπει να εκτυπωθει και αναλογα εκτυπωνω.

8)void lookup(number caller,hashtable** hashtable,int hashtable_size,int bucket_size,time time1,time time2,date year1,date year2);
Το ιδιο με την find μονο που εδω αφορα το hashtable2.

9)void insert(int,int ,cdr rec,cdr rec1,hashtable**,hashtable**,int,maxHeap**,float [])
Aρχικα ελενχω αν η καινουργια εγγραφη υπαρχει ηδη μεσα στο hashtable μου.Αν υπαρχει ηδη τοτε αυξανω τα στοιχεια της λιστας του στοιχειου στο οποιο ανηκει(realloc),αλλιως δημιουργω ενα καινουργιο bucket_node(realloc).Aν η λιστα ειναι γεματη επισης δημιουργω μια καινουργια(new_list()).Αν το bucket γεμισει απο στοιχεια τοτε επισης φτιαχνω ενα καινουργιο(new_bucket()).Στα δυο τελευταια χρησιμοποιω τις συναρτησεις που βρισκονατι στις παρενθεσεις για την διμιουργια για τι ειναι λιστες ενω για τα αλλα πιο πανω τα δημιοργω με realloc.
10)dump hashtable
ΔΕΝ ΕΧΕΙ ΥΛΟΠΟΙΗΘΕΙ.

Τελος το προγραμμα εχω προσπαθησει οσο γινεται να υλοποιηθει με ολικη αποκρυψη γιαυτο τον λογο χρησιμοποιω αρκετες βοηθητικες συναρτησεις.Aκομα εγω υλοποιησει και τις εντολες μεσω stdin οπως ζητηθηκε μετα το τελος του αρχειου.

